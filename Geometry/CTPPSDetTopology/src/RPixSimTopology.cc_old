#include "Geometry/CTPPSDetTopology/interface/RPixSimTopology.h"
#include <iostream>

RPixSimTopology::RPixSimTopology(const edm::ParameterSet &params)
{
  verbosity_ = params.getParameter<int>("RPixVerbosity");
//  no_of_sigms_to_include_ = params.getParameter<double>("RPSharingSigmas");

//  top_edge_sigma_ = params.getParameter<double>("RPTopEdgeSmearing");  //[mm]
//  bot_edge_sigma_ = params.getParameter<double>("RPBottomEdgeSmearing");  //[mm]
  active_edge_sigma_ = params.getParameter<double>("RPixActiveEdgeSmearing");  //[mm]
  
  double phys_active_edge_dist = params.getParameter<double>("RPixActiveEdgePosition");  //[mm]
  
//  active_edge_x_ = -x_width_/2.0 + phys_edge_lenght_/sqrt_2 + phys_active_edge_dist*sqrt_2;
//  active_edge_y_ = -y_width_/2.0;
  active_edge_x_ = simX_width_/2.0 - phys_active_edge_dist;
  active_edge_y_ = simY_width_/2.0 - phys_active_edge_dist;
  
//  top_edge_x_ = simX_width_/2-params.getParameter<double>("RPTopEdgePosition");  //[mm]
//  bot_edge_x_ = params.getParameter<double>("RPBottomEdgePosition")-simX_width_/2;  //[mm]
}

std::vector<pixel_info> RPixSimTopology::GetPixelsInvolved(double x, double y, double sigma, double &hit_pos_x, double &hit_pos_y)
{
  theRelevantPixels_.clear();
//  hit_pos = (no_of_strips_-1)*pitch_ -(y-last_strip_to_border_dist_+y_width_/2.0);  //hit position with respect to the center of the first strip, only in y direction
//hit position wrt the bottom left corner of the sensor (-8.3, -12.2)

  hit_pos_x = x + simX_width_/2.;
  hit_pos_y = y + simY_width_/2.;
  assert(hit_pos_x*hit_pos_y > 0);



//  double hit_pos_in_strips = hit_pos/pitch_;
  double hit_factor = ActiveEdgeFactor(x, y);//*BottomEdgeFactor(x, y)*TopEdgeFactor(x, y);
//  double range_of_interest_in_strips = no_of_sigms_to_include_*sigma/pitch_;
//  int lowest_strip_no = (int)floor(hit_pos_in_strips - range_of_interest_in_strips+0.5);
//  int highest_strip_no = (int)ceil(hit_pos_in_strips + range_of_interest_in_strips-0.5);

// if(verbosity_)
//   std::cout<<"lowest_strip_no:"<<lowest_strip_no<<"  highest_strip_no:"<<highest_strip_no<<std::endl;
/*
 if(lowest_strip_no<0)
    lowest_strip_no = 0;
  if(highest_strip_no>no_of_strips_-1)
    highest_strip_no = no_of_strips_-1;
*/

//NOTA BENE: charge sharing tra i pixel da implementare

  unsigned int interested_row = Row(hit_pos_x);
  unsigned int interested_col = Col(hit_pos_y);
  double low_pixel_range_x, high_pixel_range_x, low_pixel_range_y, high_pixel_range_y;
  PixelRange(interested_row, interested_col, low_pixel_range_x, high_pixel_range_x, low_pixel_range_y, high_pixel_range_y);

//  for(int i=lowest_strip_no; i<=highest_strip_no; ++i)
//  {
//    double low_strip_range = ((double)i-0.5)*pitch_;
//    double high_strip_range = low_strip_range+pitch_;
  theRelevantPixels_.push_back(pixel_info( low_pixel_range_x, high_pixel_range_x, low_pixel_range_y, high_pixel_range_y, hit_factor, interested_row, interested_col));
//  }
  return theRelevantPixels_;
}
